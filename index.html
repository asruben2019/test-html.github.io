<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Mueble con Cajón - Movimiento completo con caja invisible</title>
<style>
  body { margin: 0; display: flex; background-color: #f5e9d6; font-family: sans-serif; }
  #menu {
    width: 250px;
    background: #ffffffcc;
    padding: 10px;
    box-shadow: 2px 0px 5px rgba(0,0,0,0.2);
    z-index: 1;
  }
  #menu h3 { margin-top: 0; }
  #menu label { display: block; margin-top: 8px; font-size: 14px; }
  #menu input { width: 100%; padding: 5px; margin-top: 3px; }
  #menu button { margin-top: 10px; padding: 8px; width: 100%; }
  #canvas-container { flex: 1; }
</style>
</head>
<body>
  <div id="menu">
    <h3>Configurar Mueble</h3>
    <label>Alto (m):</label>
    <input type="number" id="alto" value="0.6" step="0.01" />
    <label>Ancho (m):</label>
    <input type="number" id="ancho" value="1" step="0.01" />
    <label>Fondo (m):</label>
    <input type="number" id="fondo" value="0.5" step="0.01" />
    <label>Espesor (m):</label>
    <input type="number" id="espesor" value="0.03" step="0.001" />
    <button id="generar">Generar Mueble</button>
    <hr />
    <h3>Configurar Cajón</h3>
    <label>Alto Cajón (m):</label>
    <input type="number" id="altoCajon" value="0.15" step="0.01" />
    <label>Ancho Cajón (m):</label>
    <input type="number" id="anchoCajon" value="0.4" step="0.01" />
    <label>Fondo Cajón (m):</label>
    <input type="number" id="fondoCajon" value="0.4" step="0.01" />
    <button id="addCajon">Añadir Cajón Inteligente</button>
  </div>
  <div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.118.3/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.118.3/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.118.3/examples/js/controls/DragControls.js"></script>

<script>
let scene, camera, renderer, controls, dragControls;
let mueble, muebleMedidas = {};
let cajones = [];       // grupos cajón
let dragObjects = [];   // objetos invisibles para arrastre

init();
crearMueble(1, 0.6, 0.5, 0.03);

document.getElementById('generar').addEventListener('click', () => {
  const alto = parseFloat(document.getElementById('alto').value);
  const ancho = parseFloat(document.getElementById('ancho').value);
  const fondo = parseFloat(document.getElementById('fondo').value);
  const espesor = parseFloat(document.getElementById('espesor').value);
  crearMueble(ancho, alto, fondo, espesor);
});

document.getElementById('addCajon').addEventListener('click', () => {
  const alto = parseFloat(document.getElementById('altoCajon').value);
  const ancho = parseFloat(document.getElementById('anchoCajon').value);
  const fondo = parseFloat(document.getElementById('fondoCajon').value);
  crearCajonInteligente(ancho, alto, fondo);
});

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, (window.innerWidth - 250) / window.innerHeight, 0.1, 1000);
  camera.position.set(2, 1.5, 2);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth - 250, window.innerHeight);
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 0.3, 0);
  controls.update();

  const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(3, 4, 3);
  scene.add(dirLight);

  animate();
}

function crearMueble(ancho, alto, fondo, grosor) {
  if (mueble) scene.remove(mueble);
  mueble = new THREE.Group();
  muebleMedidas = { ancho, alto, fondo, grosor };

  const matMueble = new THREE.MeshLambertMaterial({ color: 0x8b6f47 });

  const lateralGeo = new THREE.BoxGeometry(grosor, alto, fondo);
  const lateralIzq = crearPiezaConBordes(lateralGeo, matMueble);
  lateralIzq.position.set(-ancho / 2 + grosor / 2, 0, 0);
  const lateralDer = crearPiezaConBordes(lateralGeo, matMueble);
  lateralDer.position.set(ancho / 2 - grosor / 2, 0, 0);

  const supGeo = new THREE.BoxGeometry(ancho, grosor, fondo);
  const superior = crearPiezaConBordes(supGeo, matMueble);
  superior.position.set(0, alto / 2 - grosor / 2, 0);
  const inferior = crearPiezaConBordes(supGeo, matMueble);
  inferior.position.set(0, -alto / 2 + grosor / 2, 0);

  const trasGeo = new THREE.BoxGeometry(ancho - grosor * 2, alto, grosor);
  const trasero = crearPiezaConBordes(trasGeo, matMueble);
  trasero.position.set(0, 0, -fondo / 2 + grosor / 2);

  mueble.add(lateralIzq, lateralDer, superior, inferior, trasero);
  scene.add(mueble);
}

function crearPiezaConBordes(geometry, material) {
  const mesh = new THREE.Mesh(geometry, material);

  const edges = new THREE.EdgesGeometry(geometry);
  const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));

  line.raycast = () => {}; // evitar que los bordes interfieran con selección
  mesh.add(line);
  return mesh;
}

function crearCajonInteligente(ancho, alto, fondo) {
  const interiorAncho = muebleMedidas.ancho - muebleMedidas.grosor * 2;
  const interiorAlto = muebleMedidas.alto - muebleMedidas.grosor * 2;
  const interiorFondo = muebleMedidas.fondo - muebleMedidas.grosor;

  if (ancho > interiorAncho) ancho = interiorAncho;
  if (alto > interiorAlto) alto = interiorAlto;
  if (fondo > interiorFondo) fondo = interiorFondo;

  const espesorTablas = muebleMedidas.grosor / 2;
  const matCajon = new THREE.MeshLambertMaterial({ color: 0xb5651d });

  const cajonGrupo = new THREE.Group();

  // Crear piezas caras
  const base = crearPiezaConBordes(new THREE.BoxGeometry(ancho, espesorTablas, fondo), matCajon);
  base.position.set(0, -alto / 2 + espesorTablas / 2, 0);

  const lateralIzq = crearPiezaConBordes(new THREE.BoxGeometry(espesorTablas, alto, fondo), matCajon);
  lateralIzq.position.set(-ancho / 2 + espesorTablas / 2, 0, 0);

  const lateralDer = crearPiezaConBordes(new THREE.BoxGeometry(espesorTablas, alto, fondo), matCajon);
  lateralDer.position.set(ancho / 2 - espesorTablas / 2, 0, 0);

  const trasero = crearPiezaConBordes(new THREE.BoxGeometry(ancho, alto, espesorTablas), matCajon);
  trasero.position.set(0, 0, -fondo / 2 + espesorTablas / 2);

  const frente = crearPiezaConBordes(new THREE.BoxGeometry(ancho, alto, espesorTablas), matCajon);
  frente.position.set(0, 0, fondo / 2 - espesorTablas / 2);

  cajonGrupo.add(base, lateralIzq, lateralDer, trasero, frente);

  // Posición inicial
  cajonGrupo.position.set(0, -muebleMedidas.alto / 2 + alto / 2 + muebleMedidas.grosor, muebleMedidas.fondo / 2 - fondo / 2 - muebleMedidas.grosor / 2);
  scene.add(cajonGrupo);

  // Crear caja invisible para control de drag
  const cajaControlGeo = new THREE.BoxGeometry(ancho, alto, fondo);
  const cajaControlMat = new THREE.MeshBasicMaterial({ visible: false });
  const cajaControl = new THREE.Mesh(cajaControlGeo, cajaControlMat);

  cajaControl.position.copy(cajonGrupo.position);
  scene.add(cajaControl);

  // Asociar control con grupo cajón para moverlo
  cajaControl.userData.cajonGrupo = cajonGrupo;

  cajones.push(cajonGrupo);
  dragObjects.push(cajaControl);

  actualizarDragControls();
}

function actualizarDragControls() {
  if (dragControls) {
    dragControls.dispose();
  }
  dragControls = new THREE.DragControls(dragObjects, camera, renderer.domElement);

  dragControls.addEventListener('dragstart', (event) => {
    controls.enabled = false;
  });

  dragControls.addEventListener('drag', (event) => {
    const objeto = event.object;
    const grupo = objeto.userData.cajonGrupo;
    if (!grupo) return;

    // Sincronizar posición del grupo con el objeto invisible que se mueve
    grupo.position.copy(objeto.position);
  });

  dragControls.addEventListener('dragend', (event) => {
    controls.enabled = true;

    const objeto = event.object;
    const grupo = objeto.userData.cajonGrupo;
    if (!grupo) return;

    // Limitar movimiento dentro del mueble (solo en X y Z)
    const maxX = muebleMedidas.ancho / 2 - objeto.geometry.parameters.width / 2 - muebleMedidas.grosor;
    const minX = -maxX;
    const maxZ = muebleMedidas.fondo / 2 - objeto.geometry.parameters.depth / 2 - muebleMedidas.grosor / 2;
    const minZ = muebleMedidas.grosor / 2;

    if (objeto.position.x > maxX) objeto.position.x = maxX;
    if (objeto.position.x < minX) objeto.position.x = minX;
    if (objeto.position.z > maxZ) objeto.position.z = maxZ;
    if (objeto.position.z < minZ) objeto.position.z = minZ;

    // Actualizar posición del grupo tras limitar
    grupo.position.copy(objeto.position);
  });
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  const width = window.innerWidth - 250;
  const height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
});
</script>
</body>
</html>
